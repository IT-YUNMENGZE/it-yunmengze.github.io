---
layout: post
title:  "初识红黑树"
date:   2021-04-15 14:21:54
categories: 数据结构
tags:  平衡二叉树 2-3树  红黑树 
author: yunmengze
---

* content
{:toc}

## 先从二叉查找树(Binary Search Tree)说起
### 二叉查找树

**二叉查找树**是二叉树最常用的一种类型，也叫**二叉搜索树(BST)**。顾名思义，二叉查找树是为了实现快速查找而生的。不过，它不仅仅支持快速查找数据，还支持快速插入、删除数据。它是如何实现这些的呢？

这些都依赖于二叉查找树的特殊结构。**二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值。**

![img](https://cdn.jsdelivr.net/gh/IT-YUNMENGZE/ImgDB/blog_img/red-black-tree1)




### 二叉查找树的时间复杂度

实际上，二叉查找树的形态各式各样。比如这个图中，对于同一组数据，我们构造了三种二叉查找树。它们的查找、插入、删除操作的执行效率都是不一样的。图中第一种二叉查找树，根节点的左右子树极度不平衡，已经退化成了**链表**，所以查找的时间复杂度就变成了 **O(n)**。

![img](https://cdn.jsdelivr.net/gh/IT-YUNMENGZE/ImgDB/blog_img/redblacktree2.jpg)

刚刚其实分析了一种最糟糕的情况，我们现在来分析一个最理想的情况，二叉查找树是一棵完全二叉树（或满二叉树）。这个时候，插入、删除、查找的时间复杂度是多少呢？不难看出，不管操作是插入、删除还是查找，**时间复杂度其实都跟完全二叉树的高度成正比，也就是 O(height)，即为O(logn)**。

显然，极度不平衡的二叉查找树，它的查找性能肯定不能满足我们的需求。我们需要构建一种不管怎么删除、插入数据，在任何时候，都能保持任意节点左右子树都比较平衡的二叉查找树，这就是我们下一节要讲的，一种特殊的二叉查找树，平衡二叉查找树。平衡二叉查找树的高度**接近 logn**，所以插入、删除、查找操作的时间复杂度也比较稳定，是 **O(logn)**。

## 什么是平衡二叉查找树
二叉查找树是最常用的一种二叉树，它支持快速插入、删除、查找操作，各个操作的时间复杂度跟树的高度成正比，理想情况下，时间复杂度是 O(logn)。不过，二叉查找树在频繁的动态更新过程中，可能会出现树的高度远大于 log2n 的情况，从而导致各个操作的效率下降。**极端情况下，二叉树会退化为链表，时间复杂度会退化到 O(n)**。要解决这个复杂度退化的问题，我们需要设计一种平衡二叉查找树。

平衡二叉树的严格定义是这样的：二叉树中任意一个节点的左右子树的高度相差不能大于 1。从这个定义来看，完全二叉树、满二叉树其实都是平衡二叉树，但是非完全二叉树也有可能是平衡二叉树。

![img](https://cdn.jsdelivr.net/gh/IT-YUNMENGZE/ImgDB/blog_img/3-3.jpg)

平衡二叉查找树不仅满足上面平衡二叉树的定义，还满足二叉查找树的特点。最先被发明的平衡二叉查找树是 [AVL](https://zh.wikipedia.org/wiki/AVL%E6%A0%91) 树，**它严格符合我刚讲到的平衡二叉查找树的定义，即任何节点的左右子树高度相差不超过 1，是一种高度平衡的二叉查找树。**

但是很多平衡二叉查找树其实并没有严格符合上面的定义（树中任意一个节点的左右子树的高度相差不能大于 1），比如我们下面要讲的红黑树，它从根节点到各个叶子节点的最长路径，有可能会比最短路径大一倍。

发明平衡二叉查找树这类数据结构的初衷是，**解决普通二叉查找树在频繁的插入、删除等动态更新的情况下，出现时间复杂度退化的问题**。所以，平衡二叉查找树中“平衡”的意思，其实就是让整棵树左右看起来比较“对称”、比较“平衡”，不要出现左子树很高、右子树很矮的情况。这样就能让整棵树的高度相对来说低一些，相应的插入、删除、查找等操作的效率高一些。  

## 2-3树—红黑树的鼻祖

2-3树是二叉查找树的变种，树中的2和3代表两种节点，以下表示为2-节点和3-节点。

- **2-节点即普通节点：包含一个元素，两条子链接。**
- **3-节点则是扩充版，包含两个元素和三条链接：两个元素A、B，左边的链接指向小于A的节点，中间的链接指向介于A、B值之间的节点，右边的链接指向大于B的节点。**

[详情请戳](https://www.cnblogs.com/tiancai/p/9072813.html)

简而言之，2-3树的设计完全可以保证二叉树保持矮矮胖胖的状态，保持其性能良好。但是，将这种直白的表述写成代码实现起来并不方便，因为要处理的情况太多，需要维护两种不同类型的节点，将链接和其他信息从一个节点复制到另一个节点，将节点从一种类型转换为另一种类型等等。

因此，红黑树出现了，红黑树的背后逻辑就是2-3树的逻辑，但是由于用红黑作为标记这个小技巧，最后实现的代码量并不大。(但是，要直接理解这些代码是如何工作的以及背后的道理，就比较困难了。所以一定要理解它的演化过程，才能真正的理解红黑树)

我们来看看红黑树和2-3树的关联，首先，最直接的问题，红和黑的含义。红黑树中，所有的节点都是标准的2-节点，为了体现出3-节点，这里**将3-节点的两个元素用左斜红色的链接连接起来，即连接了两个2-节点来表示一个3-节点**。这里红色节点标记就代表指向其的链接是红链接，黑色标记的节点就是普通的节点。所以才会有那样一条定义，即“从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点”，因为红色节点是可以与其父节点合并为一个3-节点的，红黑树实现的其实是一个**完美的黑色平衡，**如果你将红黑树中所有的红色链接放平，那么它所有的叶子节点到根节点的距离都是相同的。所以它并不是一个严格的平衡二叉树，但是它的综合性能已经很优秀了。

所以，红黑树的另一种定义是满足下列条件的二叉查找树：

1. 红链接均为左链接。
2. 没有任何一个结点同时和两条红链接相连。(这样会出现4-节点)
3. 该树是完美黑色平衡的，即任意空链接到根结点的路径上的黑链接数量相同。

## 红黑树
### 定义

红黑树的英文是“Red-Black Tree”，简称 R-B Tree。它是一种**不严格的平衡二叉查找树**，上文说过，它的定义是不严格符合平衡二叉查找树的定义的。那红黑树究竟是怎么定义的呢？

顾名思义，红黑树中的节点，一类被标记为黑色，一类被标记为红色。除此之外，一棵红黑树还需要满足这样几个要求：

- **根节点是黑色的；**

- **每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存储数据；** 

- **任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的；**

- **每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点。**


这里的第二点要求“叶子节点都是黑色的空节点”，稍微有些奇怪，它主要是为了简化红黑树的代码实现而设置的。

![903ee0dcb62bce2f5b47819541f9069a](https://cdn.jsdelivr.net/gh/IT-YUNMENGZE/ImgDB/blog_img/3-4.jpg)

### 基本思想

不知道你有没有玩过魔方？其实魔方的复原解法是有固定算法的：遇到哪几面是什么样子，对应就怎么转几下。你只要跟着这个复原步骤，就肯定能将魔方复原。

实际上，红黑树的平衡过程跟魔方复原非常神似，大致过程就是：遇到什么样的节点排布，我们就对应怎么去调整。只要按照这些固定的调整规则来操作，就能将一个非平衡的红黑树调整成平衡的。

在插入、删除节点的过程中，红黑树的第三、第四点要求可能会被破坏，而我们今天要讲的“平衡调整”，实际上就是要把被破坏的第三、第四点恢复过来。

首先介绍两个非常重要的操作，**左旋（rotate left）**、**右旋（rotate right）**。左旋全称其实是叫**围绕某个节点的左旋**，那右旋的全称估计你已经猜到了，就叫**围绕某个节点的右旋**。我们下面的平衡调整中，会一直用到这两个操作，所以我这里画了个示意图，帮助你彻底理解这两个操作。图中的 a，b，r 表示子树，可以为空。

![img](https://cdn.jsdelivr.net/gh/IT-YUNMENGZE/ImgDB/blog_img/3-5)

具体的调整平衡操作过于复杂，限于篇幅，不详细列出，[请戳](https://time.geekbang.org/column/article/68976)